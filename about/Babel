https://ru.hexlet.io/courses/js-setup-environment/lessons/babel/theory_unit

Итак, мы знаем, что есть спецификация, а есть реализация. Знаем, что реализация, как правило, отстает от спецификации. Более того, разные реализации по разному отстают от спецификации, и написав код, мы не можем гарантировать, где он будет запускаться, а где - нет.

Исходя из этого можно сделать вывод, что нужно писать код, придерживаясь старых стандартов, но, к счастью, это не так. Другой путь состоит в том, чтобы писать код с использованием всех возможных фич, но перед публикацией автоматически транслировать (то есть переводить из одного вида в другой) его в старую версию. Звучит сложно, но на практике все просто.

Сама природа JS и его способы использования, готовят нас к тому, что никогда не настанет светлых времен и современных рантаймов. Люди использовали и продолжат использовать разные (внезапно!) браузеры и разные версии браузеров, разные версии Node.js и так далее. Совершенно закономерным ответом на эту ситуацию стало появление Babel, программы, которая берет указанный код и возвращает тот же код, но транслированный в старую версию JS. Фактически, в современном мире Babel стал неотъемлемой частью JS. Его не используют только в легаси (старых) проектах, а все новые так или иначе делают с его использованием.

У Babel есть собственный онлайн REPL. Попробуйте вставить туда любой код, который вы писали на Хекслете и посмотрите во что он превратится. Такая трансляция называется транспайлингом, а сам Babel называют транспайлером, от transpiler

// Before
const factorial = (n) => {
  if (n === 1) {
    return 1;
  }
  else {
    return n * factorial(n-1);
  }
}

// after
"use strict";

var factorial = function factorial(n) {
  if (n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
};

Сам Babel состоит из многих частей. Пакет babel-core содержит код, который выполняет всю работу по трансляции, но, при этом, не содержит внутри себя правил преобразования. Правила описаны в отдельных пакетах, называемых плагинами (например babel-plugin-transform-constant-string) . Этих плагинов настолько много, что их принято объединять в группы называемые пресетами (preset), которые затем подключаются к Babel наравне с плагинами. Ниже пример стандартного способа работы с Babel:
Установка

$ npm install --save-dev babel-core babel-cli babel-preset-env babel-preset-stage-0

Настройка

Babel полагается на наличие файла .babelrc в корне проекта. Именно через него он узнает, как нужно транслировать код. Если вы забудете добавить туда плагин или пресет, то на выходе Babel отдаст тот же код, что был и на входе.

{
  "presets": ["env", "stage-0"]
}

Минимально достаточно подключить два пресета env и stage-0, которые добавляют не только то, что уже принято в сам стандарт, но и то, что потенциально окажется в стандарте в скором времени. Можете использовать эти возможности на свой страх и риск, но, как показала практика, проблем не возникает.
Использование

Чтобы иметь возможность вызывать babel установленный как зависимость проекта, его надо добавить в scripts секцию файла package.json.

"scripts": {
  "babel": "babel"
}

Теперь можно его запустить так:

$ npm run babel -- src --out-dir dist

Эта команда берет весь код из файлов в папке src и создает его транслированную версию в папке dist. Запускается он точно так же как и любой другой код и фактически именно этот код нужно доставить в NPM репозиторий. Другими словами, пользователи вашего пакета запускают код из папки dist, а не src (хотя сами об этом не знают). Сама папка dist добавляется в .gitignore, так как сгенерированный код нужен только в момент публикации пакета для упаковки в архив, который уходит в NPM репозиторий. В процессе разработки пакета запуск сборки не требуется.

Есть только один маленький нюанс. Хотя изначально я сказал что NPM никак не интегрирован с Git, но это не совсем правда. По умолчанию NPM смотрит в файл .gitignore. Все что там перечислено не попадет в NPM репозиторий при публикации пакета. В нашем случае такой папкой является dist, но именно ее мы и хотим опубликовать. Выходов из этой ситуации несколько. Один связан с файлом .npmignore и описан в документации, про другой я скажу подробнее. NPM позволяет указать список файлов и папок, которые нужно опубликовать. Достаточно добавить секцию files в package.json. Содержимое files - массив папок и файлов:

"files": [
  "dist"
]

Существует два способа подготовки пакета к публикации. Первый - перед тем как выполнить npm publish, выполнить ручной запуск генерации папки dist используя скрипты: npm run babel -- src --out-dir dist. Подход рабочий, но сопряжен с постоянными ошибками в стиле "ой, забыл собрать новый код". К тому же, достаточно очевидно что это действие может быть автоматизировано. В этом и заключается второй подход. NPM содержит множество предопределенных скриптов, которые выполняются автоматически в определенные этапы работы. Например, prepublishOnly запускается перед непосредственным выполнением публикации. То что нам и требуется.

"scripts": {
  "build": "NODE_ENV=production babel src --out-dir dist",
  "prepublishOnly": "npm run build"
}

Если у вас Windows, вам понадобится утилита cross-env.

В примере выше используется небольшой трюк. В prepublishOnly вызывается другой скрипт - build. Сделано это исключительно для удобства (и потому что так принято). Бывают ситуации, когда все же нужно запускать сборку руками. Поэтому удобно иметь отдельную команду только для генерации. Скрипт build - как раз и призван решить эту задачу.

Подчеркну еще раз: папка dist не должна храниться в git-репозитории, и вы не найдете её на Гитхабе. Посмотрите lodash. Она генерируется только в момент публикации пакета и заливается в npm-репозиторий. Каждая новая публикация должна генерировать эту папку заново, только в этом случае обновится код в пакете.
Babel CLI

Утилита babel не очень удобна для разработки. После любых изменений хочется сразу видеть результат, без необходимости проводить компиляцию. В этом случае можно установить пакет babel-cli (можно даже глобально) и добавить в scripts запись "babel-node": "babel-node". Теперь код можно вызывать так npm run babel-node src/index.js. Обратите внимание на то что вам все равно понадобится правильно настроенный файл .babelrc в корне проекта.
Самостоятельная работа

    Попробуйте выполнить скрипт build в пакете nodejs-package. Изучите результаты его работы в папке dist.


