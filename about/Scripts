
https://ru.hexlet.io/courses/js-setup-environment/lessons/scripts/theory_unit



Одна из часто используемых секций в package.json - scripts. Ее понимание требует небольшого ликбеза в работу операционных систем (ОС).
PATH

В файловых системах ОС существует понятие "исполняемый файл" или, как часто говорят, бинарник (в реальности он не всегда бинарный). Именно эти файлы запускаются когда определенная команда в shell представлена реальной программой (и это бывает не всегда). Например, запуск ls в Bash. Кстати, узнать, где лежит этот файл можно командой which ls. Возможно, сейчас вам кажется, что в запуске программ ничего необычного нет, но дьявол кроется в деталях. Правильный вопрос звучит так: откуда shell знает, где искать этот бинарник? Ведь если взять и самостоятельно создать подобный файл и назвать его hey, а потом положить в произвольное место системы, то попытка запустить hey ни к чему не приведет.

$ hey
-bash: hey: command not found

В ОС существует такое понятие как переменные окружения, мы не будем говорить про них подробно (об этом в курсах по командной строке), но общий принцип следующий, переменные окружения глобальны и доступны всем. Их основное предназначение - конфигурация. Так вот существует некая системная переменная PATH, внутри которой содержатся пути, по которым shell ищет то, что вы пытаетесь запустить. Вот вывод на моем ноутбуке:

echo $PATH
/usr/local/sbin:/usr/local/opt/postgresql@9.5/bin:~/.composer/vendor/bin:~/.yarn/bin:/var/tmp/nim/bin:~/.local/bin:~/.nimble/bin:~/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/share/dotnet:/Library/Frameworks/Mono.framework/Versions/Current/Commands

: отделяет пути друг от друга. Этот список у всех разный, так как его можно настраивать и многие программы это делают автоматически. Иногда приходится его расширять самостоятельно.

Теперь вспомним, как мы устанавливаем программы из npm-репозитория: sudo npm -g install sloc, а после этого, магически становится доступен вызов sloc в нашем shell. Но как? А дело в том, что если установка глобальная и у нас достаточно прав, то NPM берет бинарники из пакета (для их определения есть свои секции в package.json) и помещает по одному из путей указанных в PATH. Как правило, по умолчанию, это /usr/local/bin, но он может отличаться в разных системах. Посмотреть его можно так:

$ npm config ls -l
; cli configs
metrics-registry = "https://registry.npmjs.org/"
scope = ""
user-agent = "npm/5.6.0 node/v9.4.0 darwin x64"

; builtin config undefined
prefix = "/usr/local"

; node bin location = /usr/local/Cellar/node/9.4.0/bin/node
; cwd = /Users/mokevnin
; HOME = /Users/mokevnin
; "npm config ls -l" to show all defaults.
...

Обратите внимание на параметр prefix. Именно он используется для построения полного пути: ${prefix}/bin.

Но все не так с зависимостями пакета. Они ставятся в локальную папку node_modules и их бинарники не копируются по системным путям, а значит установив любую зависимость имеющую бинарник, вы не сможете взять и вызвать его. Точнее сможете, но вам придется явно прописывать путь: ./node_modules/sloc/bin/sloc.js. Но есть и другой путь.
Scripts

Секция Scripts позволяет описывать произвольные команды, которые затем можно выполнять. Ее особенностью является то, что NPM в контекст выполнения команды добавляет путь /node_modules/.bin в PATH (только для текущего вызова!). А папка node_modules/.bin это место куда NPM складывает бинарники всех локально установленных пакетов.

Рассмотрим пример. Предположим, что мы установили программу sloc как зависимость. Следующим шагом нужно создать в Scripts следующую запись: "sloc": "sloc". Имя свойства используется как команда в командной строке, значение - то, что реально исполнится. Теперь если вы попробуете сделать так: npm run sloc то все отработает как и ожидается.

Некоторые свойства в Scripts имеют особое значение. Например, на Хекслете код проверяется автоматическими тестами с использованием библиотеки jest. Она содержит бинарник с тем же именем и все что нужно сделать для запуска тестов - выполнить команду jest. Мы могли бы сделать в скриптах такую запись: "jest": "jest", но именно для тестов NPM предлагает делать так: "test": "jest". Главное отличие подобных встроенных команд, в их способе запуска. Достаточно набрать npm test вместо npm run test, хотя второй вариант также сработает.

nodejs-package$ npm test

> nodejs-package@0.0.1 test /Users/mokevnin/hexlet/nodejs-package
> jest

 PASS  __tests__/half.test.js
  ✓ half (3ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.242s, estimated 1s
Ran all test suites.

npx

Пакет npx позволяет запускать программы установленные локально без необходимости прописывать их в scripts. Установив его глобально, вы получите возможность вызвать любой локальный бинарник так npx jest
Hooks

Есть целый набор предопределенных свойств в Scripts, которые NPM запускает автоматически в разные моменты жизни. Подробнее об этом можно прочитать в официальной документации. А здесь я покажу буквально один пример. Свойство prepublishOnly используется тогда, когда перед публикацией пакета в репозиторий NPM необходимо выполнить некоторые действия, например сгенерировать документацию. Команда указанная в нем запустится во время выполнения npm publish.
Самостоятельная работа

    Попробуйте выполнить скрипт test в пакете nodejs-package


